library(httr)
library(jsonlite)
url <- "http://api.openweathermap.org/data/2.5/weather"
api_key <- "Enter API KEY"
city <- "New Delhi"
country <- "IN"
params <- list(q = paste(city,country,sep =",") , appid=api_key)
res <- GET(url,query=params)
ans <- fromJSON(content(res,"text"),flatten=TRUE)
tem <- ans$main$temp - 273.15
print(paste("The temperature is", round(tem,2), "C in", city))
tem
install.packages("httr2")
library(httr2)
req <- request(example_url())
?GET
# ==============================================================================
#            SESSION ONE: DOWNLOADING AND FILTERING iNaturalist DATA
# ==============================================================================
# Load Required Packages
library(rinat)
library(httr)
library(lubridate)
# ------------------------------------------------------------------------------
#                      Download Data from the iNaturalist Project
# ------------------------------------------------------------------------------
# Define project ID and API parameters
project_slug <- "brpc-national-bioblitz-2025-practice"
# Download data using the rinat package
inat_data <- get_inat_obs_project(project_slug)
# Convert observed_on to date-time for comparison
inat_data$updated_at <- ymd_hms(inat_data$updated_at)
inat_data$time_observed_at <- ymd_hms(inat_data$time_observed_at)
last_update <- max(inat_data$updated_at)
cat("Last update:", as.character(last_update), "\n")
# ------------------------------------------------------------------------------
#                     Adding World Register of Marine Species Data
# ------------------------------------------------------------------------------
library(jsonlite)
library(dplyr)
# ------------------------------------------------------------------------------
#        Add and fill columns for Order and Family to iNaturalist dataframe
# ------------------------------------------------------------------------------
# Create new empty columns to merge with inat_data for taxonomy data
taxon.kingdom = rep(NA, times = length(inat_data[,1]))
taxon.phylum = rep(NA, times = length(inat_data[,1]))
taxon.class = rep(NA, times = length(inat_data[,1]))
taxon.order = rep(NA, times = length(inat_data[,1]))
taxon.family = rep(NA, times = length(inat_data[,1]))
marine = rep(NA, times = length(inat_data[,1]))
brackish = rep(NA, times = length(inat_data[,1]))
freshwater = rep(NA, times = length(inat_data[,1]))
terrestrial = rep(NA, times = length(inat_data[,1]))
# Merge the inat_data dataframe with the new taxon columns
inat_data = cbind(inat_data,
taxon.kingdom,
taxon.phylum,
taxon.class,
taxon.order,
taxon.family,
marine,
brackish,
freshwater,
terrestrial
)
# clean up the global environment
rm(taxon.kingdom,
taxon.phylum,
taxon.class,
taxon.order,
taxon.family,
marine,
brackish,
freshwater,
terrestrial
)
# filling in new inat_data columns with taxonomic information from WoRMS
l = length(inat_data[,1])
for (a in 1:l) {
if (is.na(inat_data$taxon.rank[a])==FALSE && inat_data$taxon.rank[a]=="species"){
binomClassNm = inat_data$taxon.name[a]
binomClassNmSplit = strsplit(binomClassNm,"[ ]")
genus = binomClassNmSplit[[1]][1]
species = binomClassNmSplit[[1]][2]
api = paste("https://www.marinespecies.org/rest/AphiaRecordsByName/",
genus,
"%20",
species,
"?like=true&marine_only=false&extant_only=true&offset=1",sep = "")
taxonInfo = GET(api)
taxonInfoContent = httr::content(taxonInfo, as = 'text')
if(object.size(taxonInfoContent)>112) {
taxonInfoContentJSON = jsonlite::fromJSON(taxonInfoContent)
inat_data$taxon.kingdom[a] = taxonInfoContentJSON$kingdom[1]
inat_data$taxon.phylum[a] = taxonInfoContentJSON$phylum[1]
inat_data$taxon.class[a] = taxonInfoContentJSON$class[1]
inat_data$taxon.order[a] = taxonInfoContentJSON$order[1]
inat_data$taxon.family[a] = taxonInfoContentJSON$family[1]
if(is.na(taxonInfoContentJSON$isMarine[1])==FALSE) {
inat_data$marine[a] = taxonInfoContentJSON$isMarine[1]
}
if(is.na(taxonInfoContentJSON$isBrackish[1])==FALSE) {
inat_data$brackish[a] = taxonInfoContentJSON$isBrackish[1]
}
if(is.na(taxonInfoContentJSON$isFreshwater[1])==FALSE) {
inat_data$freshwater[a] = taxonInfoContentJSON$isFreshwater[1]
}
if(is.na(taxonInfoContentJSON$isTerrestrial[1])==FALSE) {
inat_data$terrestrial[a] = taxonInfoContentJSON$isTerrestrial[1]
}
} else {
inat_data$taxon.kingdom[a] = "taxon info not retrieved"
}
}
}
# ------------------------------------------------------------------------------
#                             Step 1: Map of Anemones
# ------------------------------------------------------------------------------
library(leaflet)
library(scales)
################################################################################
inat_data_filtered = inat_data
inat_data_filtered = filter(inat_data_filtered,marine == 1 | brackish == 1)
getwd()
setwd("C:/Users/Rose/")
setwd("C:/Users/Rose")
setwd("C:/Users/Rose/lichen_mapping")
genus = binomNmSplit[[1]][1]
# install.packages("httr")
# install.packages("jsonlite")
library(httr)
library(jsonlite)
getNBNData = function(latinName,numRecords){
# Split species name into genus and species to parse the API for NBN Atlas
binomNmSplit = strsplit(latinName,"[ ]")
genus = binomNmSplit[[1]][1]
species = binomNmSplit[[1]][2]
if (species != "sp.") {
api=paste("https://records-ws.nbnatlas.org/occurrences/search?",
"q=*:*&fq=genus:",
genus,
"&fq=-(identification_verification_status%3A%22Unconfirmed%22%20OR",
"%20identification_verification_status%3A%22Unconfirmed%20-%20",
"not%20reviewed%22%20OR%20identification_verification_status%3A%22",
"Unconfirmed%20-%20plausible%22)&fq=-occurrence_status%3A%22absent",
"%22&fq=taxon_name%3A%22",
genus,
"%20",
species,
"%22&pageSize=",numRecords,sep = "")
} else {
api=paste("https://records-ws.nbnatlas.org/occurrences/search?",
"q=*:*&fq=genus:",
genus,
"&fq=-(identification_verification_status%3A%22Unconfirmed%22%20OR",
"%20identification_verification_status%3A%22Unconfirmed%20-%20",
"not%20reviewed%22%20OR%20identification_verification_status%3A%22",
"Unconfirmed%20-%20plausible%22)&fq=-occurrence_status%3A%22absent",
"%22&fq=taxon_name%3A%22",
genus,
"%22&pageSize=",numRecords,sep = "")
}
taxonInfo = GET(api)
taxonInfoContent = httr::content(taxonInfo, as = 'text')
taxonInfoContentJSON = jsonlite::fromJSON(taxonInfoContent)
df=taxonInfoContentJSON$occurrences
return(df)
}
porpoise = getNBNData("Phocoena phocoena",10000)
View(porpoise)
unique(porpoise$basisOfRecord)
library(dplyr)
library(sf)
library(sf)
library(rnaturalearth)
library(sf)
library(rnaturalearth)
# kernel density map
library(sp) # for setting up the layers to map
library(adehabitatHR)
library(raster)
library(showtext)
# library(ggtext)
# Fonts for plots
font_add_google("Montserrat", "mont")
# library(ggtext)
# Fonts for plots
font_add_google("Montserrat", "mont")
font_add_google("Chivo", "chivo")
# Download the base map of UK and surrounding countries
uk_map <- ne_countries(
scale = "medium",
returnclass = "sf"
) %>%
filter(admin %in% c("United Kingdom", "Ireland",
"Jersey","France","Netherlands","Germany",
"Denmark","Belgium","Norway","Finland","Sweden"))
# String of species names to loop through
# "Pseudevernia furfuracea" - need to add to nSensitive
nSensitive = c("Evernia prunastri","Usnea sp.",
"Bryoria sp.","Sphaerophorus globosus","Hypogymnia sp.",
"Parmelia sp.","Graphis sp.","Ochrolechia androgyna")
# "Punctelia subrudecta" - nTolerant
nTolerant = c("Xanthoria parietina","Xanthoria polycarpa","Xanthoria ucrainica",
"Physcia adscendens","Physcia tenella",
"Arthonia radiata","Lecidella elaeochroma","Amandinea punctata",
"Candelariella reflexa")
indicatorSpp = nSensitive
a=1
indicatorSpp[a]
lichen = getNBNData(indicatorSpp[a],10000)
View(lichen)
unique(lichen$raw_occurrenceRemarks)
table(as.factor(lichen$raw_occurrenceRemarks))
unique(lichen$raw_occurrenceRemarks)
unique(lichen$basisOfRecord)
# Projection/CRS of base map, NBN Atlas coordinates:
#     - WGS 84
plot(st_geometry(uk_map),border="#f9fdf9",axes=TRUE,
xlim=c(-15,5),ylim=c(48.5,61.5),
col="#d8dedd",cex.axis=0.8)
z=1
if(z==1) {
pointsCol = "#78C6C0"
mainTitle = "Nitrogen-sensitive Lichen"
} else {
pointsCol = "#c6787e"
mainTitle = "Nitrogen-tolerant Lichen"
}
points(as.numeric(df$decimalLongitude),
as.numeric(df$decimalLatitude),
pch = 19,
cex = 0.6,
col=pointsCol)
title(main = binomClassNm,cex.main = 0.9,line = -1)
op = par(mfrow=c(1,2), font.lab = 2,
mar=c(2,2.5,1,0.1)+0.1,
oma=c(0.01,0.01,2,0.01),xpd=FALSE)
################################################################################
#                 Maps of records from the NBN Atlas
################################################################################
# Download the base map of UK and surrounding countries
uk_map <- ne_countries(
scale = "medium",
returnclass = "sf"
) %>%
filter(admin %in% c("United Kingdom", "Ireland",
"Jersey","France","Netherlands","Germany",
"Denmark","Belgium","Norway","Finland","Sweden"))
# String of species names to loop through
# "Pseudevernia furfuracea" - need to add to nSensitive
nSensitive = c("Evernia prunastri","Usnea sp.",
"Bryoria sp.","Sphaerophorus globosus","Hypogymnia sp.",
"Parmelia sp.","Graphis sp.","Ochrolechia androgyna")
# "Punctelia subrudecta" - nTolerant
nTolerant = c("Xanthoria parietina","Xanthoria polycarpa","Xanthoria ucrainica",
"Physcia adscendens","Physcia tenella",
"Arthonia radiata","Lecidella elaeochroma","Amandinea punctata",
"Candelariella reflexa")
# Set graphical parameters for the maps
op = par(mfrow=c(2,4), font.lab = 2,
mar=c(2,2.5,1,0.1)+0.1,
oma=c(0.01,0.01,2,0.01),xpd=FALSE)
###### Get NBN Atlas data and map the records ######
for (z in 1:2) {
if (z == 1){
indicatorSpp = nSensitive
} else {
indicatorSpp = nTolerant
}
for (a in 1:length(indicatorSpp)) {
# Split species name into genus and species to parse the API for NBN Atlas
df = getNBNData(indicatorSpp[a],100)
############### Map the records from NBN Atlas ##################
# Projection/CRS of base map, NBN Atlas coordinates:
#     - WGS 84
plot(st_geometry(uk_map),border="#f9fdf9",axes=TRUE,
xlim=c(-15,5),ylim=c(48.5,61.5),
col="#d8dedd",cex.axis=0.8)
if(z==1) {
pointsCol = "#78C6C0"
mainTitle = "Nitrogen-sensitive Lichen"
} else {
pointsCol = "#c6787e"
mainTitle = "Nitrogen-tolerant Lichen"
}
points(as.numeric(df$decimalLongitude),
as.numeric(df$decimalLatitude),
pch = 19,
cex = 0.6,
col=pointsCol)
title(main = indicatorSpp[a],cex.main = 0.9,line = -1)
mtext(mainTitle,
side = 3, line = -0.14, outer = TRUE,col = c("#131713"),
font = 2,cex = 1.05)
################ kernel density map #################################
# Create colour ramp for kernel density estimation of observations
# using The Rock Pool Project brand colours
fun_colour_range <- colorRampPalette(c("#d8dedd",pointsCol))
my_colours <- fun_colour_range(1000)
# Setting up the layers to map
sdf = data.frame(as.numeric(df$decimalLongitude),
as.numeric(df$decimalLatitude))
s = SpatialPoints(na.omit(sdf))
kde.output <- kernelUD(s,h="href", grid = 1000)
# converts to raster
kde <- raster(kde.output)
# sets projection to British National Grid
projection(kde) <- CRS("+init=EPSG:27700")
masked_kde <- mask(kde, uk_map)
plot(masked_kde,col=my_colours,axes=TRUE,
xlim=c(-15,5),ylim=c(48.5,61.5))
plot(st_geometry(uk_map),add = TRUE,border="#f9fdf9")
title(main = indicatorSpp[a],cex.main = 0.9,line = -1)
rm(df)
}
}
nTolerant
